# 概论
数据库：按照特定数据模型组织、存储和管理数据的文件集合

数据模型：描述事物对象数据特征及其结构的形式化表示，包含数据结构、数据操作、数据约束3个部分
层次、网状、关系、其它数据模型

数据库系统：基于数据库进行数据管理与信息服务的软件系统
组成：用户、数据库应用程序、数据库管理系统(DBMS)、数据库

数据库管理系统(DBMS)：专门用来创建、管理、维护数据库，并提供外部对数据库进行访问的系统软件

数据库应用系统类型：业务处理系统、管理信息系统、决策支持系统
数据库系统应用结构：单机用户结构、集中式结构、客户/服务器结构、分布式结构

关系数据库中数据内容：
- 用户数据
- 元数据：定义数据库对象（表、列、索引、视图）的数据（描述数据的数据）
- 索引数据
- 运行数据
- 其它数据

# 关系模型
关系模型：基于二维表结构存储数据实体及实体间联系的数据模型
实体：包含有数据特征的事物对象在概念模型世界中抽象名称
关系（关系表）：有关系特征、用于存放实体数据的二维表

键：用来唯一表示元组的属性列
候选键：一个关系中可能有多个列，每个键称为候选键
主键：关系表中最有代表性的**一个**候选键
复合键：多个属性所构成的键
代理键：DBMS自动生成的数字序列作为关系表的主键
外键：通过主键属性相关联的两个关系表中，该主键属性在一个表中作为主键，在另一个表中作为外键

关系模型完整性：在关系数据模型中对关系实施的完整性约束
组成：
- 实体完整性约束
	在关系表中实施的主键取值约束，保证每个元组唯一标识
	规则：
	1. 主键属性列不允许为NULL
	2. 主键取值唯一
- 参照完整性约束
	关系表之间需要遵守的数据约束，保证关系之间关联列的数据一致性
	规则：若关系R中外键F与关系S中主键K关联，则F、K值一致
- 用户自定义完整性约束
	用户根据具体业务对数据处理规则要求所定义的数据约束

**关系运算**
# SQL语言
1. 数据定义语言（DDL）：CREATE、DROP、ALTER
2. 数据操纵语言（DML）：INSERT、UPDATE、DELETE
3. 数据查询语言（DQL）
4. 数据控制语言（DCL）：GRANT、DENY、REVOKE
5. 事物处理语言（TPL）：BEGIN TRANSACTION、COMMIT、ROLLBACK
6. 游标控制语言（CCL）：DECLARE CURSOR、FETCH INTO、CLOSE CURSOR

列完整性约束：
- PRIMARY KEY
- NOT NULL
- NULL
- UNIQUE
- CHECK：`CHECK(<行名> IN('<value1>', 'value2', 'value3'))`
- DEFAULT：`DEFAULT 'value'`
表约束：
- 复合主键
	`CONSTRAINT <复合键名> PRIMARY Key(<列名1>, <列名2>)`
- 代理键
	`CONSTRAINT <代理键名> PRIMARY Key(<列名>)`
	`<列名>`需是：`serial`
- 外键
	`CONSTRAINT <外键名> FOREIGN Key(外键列名) REFERENCES <参照表>(参照列)`

DDL：
- 增删 表、列、完整性约束、索引
- 修改 表、列、完整性约束、索引 名
- 修改 列属性
```sql
--增加 default 约束
ALTER TABLE 表名
ALTER COLUMN 列名 SET DEFAULT 默认值;

--修改约束名
ALTER TABLE 表名
RENAME CONSTRAINT 旧约束名 TO 新约束名;
```
新增列时**不能添加**`NULL`，数据库不知道如何为所有行添加该属性值，可设为`DEFAULT`或`NOT NULL`

DML：
插入、更新、删除 表数据

DQL：
- 限定范围
- 通配符
- 逻辑运算
- `IN`
- 排序`DESC`、`ASC`
- 聚合函数
- 分组统计
- `HAVING`筛选分组
- 子查询
- 两种连接关联查询

DCL：
- 授予、收回、拒绝 权限

视图的创建、删除
通过视图查询、查询视图
# 数据库设计
数据库设计：应用架构设计、结构模型设计、访问方式设计
数据库结构模型：
- 概念数据模型（CDM）
- 逻辑数据模型（LDM）
- 物理数据模型（PDM）

| CDM             | LDM                             | PDM     |
| --------------- | ------------------------------- | ------- |
| 实体              | 实体                              | 表       |
| 属性              | 属性                              | 列       |
| 标识符（Identifier） | 标识符（Primary/Foreign Identifier） | 键       |
| 联系              | 联系                              | 参照完整性约束 |
ER图元素：
1. 实体
2. 属性
3. 标识符
4. 联系
	联系度数：联系中关联实体数目
	基数：可能参与联系的实例的数量

实体-联系类型：
1. 多重性分类
	- 1对1
	- 1对多
	- 多对多
2. 参与性分类
	- 可选
	- 强制
3. 继承性分类
	- 互斥继承：父实体中的一个实例只能属于某个子实体
	- 非互斥继承：父实体的一个实例可以属于多个子实体
	- 完整继承：父实体中的实例完整地被各个子实体分别继承
	- 非完整继承

强弱实体：一个实体（弱实体）的存在必须以另一个实体（强实体）的存在为前提
弱实体：
- 标识符依赖弱实体
- 非标识符弱实体

数据库建模设计：
1. CDM：
	- 定义实体、实体联系、实体属性、标识符
	- 不定义主、外键
2. LDM：
	- 主、外键定义
	- 范式检查
3. PDM：
	1. 实体→关系表
		- 设置代理键
		- 设置列特性
	2. 弱实体→关系表
		- 非标识符依赖：弱实体关系表中加入强实体标识符做外键
		- 标识符依赖：弱实体关系表中加入强实体标识符做外键，并与若实体标识符一起做复合主键
	3. 实体联系转换
		- 1:1转换：一个表主键放入另一个表做外键
		- 1:N转换：1端主键放入N端做外键
		- M:N转换：增加关联表，M、N端实体在关联表中做复合主键、外键
		- 1:1转换：
	4. 实体继承联系转换
		父表主键放在子表做主、外键
	5. 实体递归联系转换
		- 1:N递归联系：关系表中添加一个参照约束于主键的外键
		- M:N递归联系：增加关联表，原表的主键在关联表中派生两次做复合主键、外键

函数依赖：
- 完全函数依赖
- 部分函数依赖
- 传递函数依赖
- 多值依赖

关系规范化范式：
1. 第1范式：关系表中的属性不可再分
2. 第2范式：1NF之上消除属性部分函数依赖
3. 第3范式：2NF之上切断属性传递函数依赖
4. 巴斯-科德范式：任意一个非平凡函数依赖X->A，都满足X是R的一个超键
5. 第4范式：BCNF之上消除多值函数依赖

# 数据库管理
为什么需要数据库管理：
- 随规模增大，系统复杂
- 多用户数据库应用→访问复杂性
- 数据安全、隐私
- 数据量增加、使用时间增长→性能降低
- 意外事件→数据库损坏、数据丢失

数据库管理目标：
- 稳定运行、存取性能
- 软硬件处理能力
- 系统安全、用户隐私
- 管理用户、角色权限
- 性能优化、系统故障、机器损坏
- 信息资产作用

DBMS层次结构：
1. 访问接口层
2. 语言翻译处理层
3. 数据存取控制层
4. 数据存储管理层

数据库存储结构：
- 逻辑存储结构
- 物理存储结构
	至少有：数据文件、控制文件、重做日志文件

数据文件记录结构：
1. 定长记录
2. 变长记录

数据文件的记录组织：
1. 堆文件组织
2. 顺序文件组织
3. 多表聚簇文件组织
4. Hash文件组织

数据字典：存放数据库元数据的系统数据库表及其视图
存储以下类型的元数据：
- 数据库表、视图的结构数据
- 系统角色、用户数据
- 索引数据

存储引擎：
- 外存管理器
- 内存数据缓存区
- 缓冲区管理器
- 索引管理器

B+树索引：
- 根、中间层节点：索引的搜索键值、下层节点指针
- 叶节点：索引的搜索键值、数据记录指针、链表指针

散列表索引：
- 散列函数
- 散列冲突解决

事务：由构成单个逻辑处理单元的一组数据库访问操作，要么都被成功执行，要么都不执行
![](image/Pasted%20image%2020250426113057.png)
ACID特性：
- 原子性（Atomicity）：要么全正确执行，要么全不执行
- 一致性（Consistency）：从一种正确的数据状态变迁到另一种正确的数据状态
- 隔离性（Isolation）：事物之间隔离，并发执行透明
- 持续性（Durability）：一旦提交，对数据的改变是永久的

事务SQL编程：
- `BEGIN`或`START TRANSACTION`：开始
- `COMMIT`：提交
- `ROLLBACK`：回滚
- `SAVEPOINT`：保存点

事务处理**不能**有DDL类语句：该类语句会自动提交，导致事务终端
DBMS默认每个语句构成一个事务

并发控制的目的：
- 支持并发事务，多用户并行操作
- 保证一个事务的工作不会对另一个事务的工作产生不合理影响

并发需要解决的问题：
1. 脏读：事务读取了取消被持久化的共享数据
2. 不可重复读：事务对同一共享数据重复读取，前后读取的数据不同
3. 幻象读：事务对同一共享数据重复读取，第二次读取的结果比第一读取的结果新增数据
4. 丢失更新：事务对共享数据进行更新后查询值与其更新值不同

并发事务调度：控制多个事务数据操作语句按照恰当顺序访问共享数据，使这些事务执行后，避免数据的不一致性

DBMS并发事务调度目标：使并发事务调度实现的处理结果与串行化调度处理结果一致

排他锁（Lock-X）：写锁，可以读、写，其它事务不能对共享数据加任何锁
共享锁（Lock-S）：读锁，只能读，其它事务只能再加S锁

锁的相容性：

|   类型    | 排他锁 | 共享锁 | 无锁  |
| :-----: | :-: | :-: | :-: |
| **排它锁** |  否  |  否  |  是  |
| **共享锁** |  否  |  是  |  是  |
| **无锁**  |  是  |  是  |  是  |

加锁协议：
1. 一级加锁协议：修改前加排它锁，事务完成后释放
	解决：丢失更新
2. 二级加锁协议：一级之上，读取前加共享锁，读后立即释放
	解决：脏读
3. 三级加锁协议：一级之上，读取前加共享锁，事务结束后释放
	解决：不可重复读


| 加锁协议级别 | 排他锁 | 共享锁  | 丢失更新 | 脏读  | 不可重复读 |
| :----: | :-: | :--: | :--: | :-: | :---: |
|   一级   | 全程  |  不加  |  否   |  是  |   是   |
|   二级   | 全程  | 读完释放 |  否   |  否  |   是   |
|   三级   | 全程  |  全程  |  否   |  否  |   否   |

并发事务的正确调度准则：一个并发事务调度，当且仅当可串行化时，才能保证正确调度
保证可串行化协议：二阶段锁定协议
二阶段锁定协议：
- 增长阶段：获得锁，不能释放锁
- 缩减阶段：释放锁，不能获得锁

事务死锁：并发事务执行时，同时锁定两个及以上资源时，彼此都不能继续执行的状态
死锁必要条件：
- 互斥条件
- 请求和保持条件
- 不可剥夺条件
- 环路等待条件
防范策略：
- 一次锁定全部所需资源
- 锁定资源顺序相同
解决死锁的办法：回滚一个事务

事务隔离级别：通过设置隔离级别来解决并发事务访问数据问题

| 隔离级别  | 脏读  | 不可重复读 | 幻像读 |
| :---: | :-: | :---: | :-: |
| 读取未提交 | 可能  |  可能   | 可能  |
| 读取已提交 | 不可能 |  可能   | 可能  |
| 可重复读  | 不可能 |  不可能  | 可能  |
| 可串行化  | 不可能 |  不可能  | 不可能 |
1. 读取未提交：允许读取未提交数据
2. 读取已提交：只允许读取已提交数据
3. 可重复读：2.之上两次读取时其他事务不允许**更新**（不是插入）
4. 可串行化

安全模型：
- 身份验证：应用系统层
- 权限控制：DBMS系统层
- 系统防护：操作系统层
- 加密存储：数据存储层

安全管理：
- 用户管理：创建、修改、删除用户
- 权限管理
	- 权限类别：
		1. 对象访问权限
		2. 对象定义权限
	- 权限管理：
		```sql
		GRANT <权限列表> ON <数据库对象> TO <用户或角色>;
		REVOKE <权限列表> ON <数据库对象> FROM <用户或角色>;
		DENY <权限列表> ON <数据库对象> TO <用户或角色>;
		```
- 角色管理
	- 角色：一组相同权限的用户
	- 管理内容：创建、修改、删除角色

数据库备份：将数据、状态进行副本复制
数据库恢复：将数据丢失或被破坏时，从备份副本将数据库恢复到某一正确状态

备份内容：用户、系统数据库
备份方式：
- 完整数据库备份
- 差异数据库备份
- 事务日志备份
- 文件备份

根据是否需要停止实例运行：
- 冷备份
- 热备份

数据库恢复
1. 恢复场景
	- 事务故障的数据恢复
	- 系统崩溃的数据恢复
	- 存储介质损坏的数据恢复
2. 恢复技术
	利用数据库备份文件和数据库系统事务日志文件来实现数据库恢复处理

# 数据库函数编程
```sql
--声明变量
DECLARE
	<变量名> <变量类型>;

--行类型变量
<变量名> <表名>% ROWTYPE;

--用已有变量定义新变量
<变量1> <变量2>% TYPE;
<变量> <表名>.<列名>% TYPE;
```
- `RECORD`类型变量是数据类型的占位符

```sql
--IF
IF <布尔> THEN
END IF;

--IF-THEN-ELSIF-ELSE
IF <布尔> THEN
……
ELSIF <布尔> THEN
……
ELSE
……
END IF;

--CASE
CASE
	WHEN <条件> THEN
		……;
	WHEN <条件> THEN
		……;
	……
	ELSE
		……;
END CASE;

--LOOP, 用EXIT, RETURN跳出循环
LOOP
	……
END LOOP;

--WHILE
WHILE <条件> LOOP
	……
END LOOP;

--FOR, 两个'.'
FOR i IN 1..<max> LOOP
	……
END LOOP;

--遍历结果
FOR <变量> IN <query> LOOP
	……
END LOOP;

--异常
BEGIN
	<语句>；
	EXCEPTION WHEN <异常> THEN
	<处理异常>;
END;
```


