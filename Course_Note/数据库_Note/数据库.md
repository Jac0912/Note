# 1. 概论
数据库：按照特定数据模型组织、存储和管理数据的文件集合

数据模型：描述事物对象数据特征及其结构的形式化表示，包含数据结构、数据操作、数据约束 3 个部分
层次、网状、关系、其它数据模型

数据库系统：基于数据库进行数据管理与信息服务的软件系统
组成：用户、数据库应用程序、数据库管理系统 (DBMS)、数据库

数据库管理系统 (DBMS)：专门用来创建、管理、维护数据库，并提供外部对数据库进行访问的系统软件

数据库应用系统类型：业务处理系统、管理信息系统、决策支持系统
数据库系统应用结构：单机用户结构、集中式结构、客户/服务器结构、分布式结构

关系数据库中数据内容：
- 用户数据
- 元数据：定义数据库对象（表、列、索引、视图）的数据（描述数据的数据）
- 索引数据
- 运行数据
- 其它数据

数据库文件与普通数据文件区别：
- 数据库支持不同应用对数据共享访问
- 数据库实现复杂的数据管理
- 数据库可独立应用程序，普通数据文件与应用程序紧耦合
- 数据库访问控制管理由DBMS实现，普通数据文件由应用程序实现

NoSQL共同特征：不需要预定义模式，无共享架构，弹性可扩展，分区，异步复制，BASE
NoSQL采用技术：简单数据类型，元数据和应用数据分离，弱一致性

NoSQL优缺：
- 优：高可扩展性，分布式计算，低成本，架构灵活性，半结构化数据，无复杂关系
- 缺：没标准化，有限查询功能，最终一致不直观

NoSQL数据库分类：

| 分类      | 举例      | 模型                               | 优点                         | 缺点                            |
| ------- | ------- | -------------------------------- | -------------------------- | ----------------------------- |
| 键值      | Redis   | Key-Value                        | 查找速度快                      | 数据无结构化，当作字符串或者二进制数据           |
| 列存储数据库  | HBase   | 同一列的数据存储在一起，存储结构化和半结构化数据         | 查找速度快，扩展性强，容易分布式扩展         | 功能相对局限                        |
| 文档存型数据库 | MongoDB | 存储文档型内容，用格式化文件（类似json、XML等）的格式存储 | 数据结构要求不严格，表结构可变，不需要预先定义表结构 | 查询性能低，缺乏统一查询语法                |
| 图形数据库   | Neo4j   | 有向加权图方式存储数据                      | 利用图结构相关算法。如最短路径寻址，N度关系查找等  | 需要对整个图做计算才能得出需要的信息，难做分布式的集群方案 |

# 2. 关系模型
关系模型：基于二维表结构存储数据实体及实体间联系的数据模型
实体：包含有数据特征的事物对象在概念模型世界中抽象名称
关系（关系表）：有关系特征、用于存放实体数据的二维表

键：用来唯一表示元组的属性列
候选键：一个关系中可能有多个列，每个键称为候选键
主键：关系表中最有代表性的**一个**候选键
复合键：多个属性所构成的键
代理键：DBMS 自动生成的数字序列作为关系表的主键
外键：通过主键属性相关联的两个关系表中，该主键属性在一个表中作为主键，在另一个表中作为外键

关系模型完整性：在关系数据模型中对关系实施的完整性约束
组成：
- 实体完整性约束
	在关系表中实施的主键取值约束，保证每个元组唯一标识
	规则：
	1. 主键属性列不允许为 NULL
	2. 主键取值唯一
- 参照完整性约束
	关系表之间需要遵守的数据约束，保证关系之间关联列的数据一致性
	规则：若关系 R 中外键 F 与关系 S 中主键 K 关联，则 F、K 值一致
- 用户自定义完整性约束
	用户根据具体业务对数据处理规则要求所定义的数据约束

**关系运算**
# 3. SQL 语言
1. 数据定义语言（DDL）：CREATE、DROP、ALTER
2. 数据操纵语言（DML）：INSERT、UPDATE、DELETE
3. 数据查询语言（DQL）
4. 数据控制语言（DCL）：GRANT、DENY、REVOKE
5. 事物处理语言（TPL）：BEGIN TRANSACTION、COMMIT、ROLLBACK
6. 游标控制语言（CCL）：DECLARE CURSOR、FETCH INTO、CLOSE CURSOR

列完整性约束：
- PRIMARY KEY
- NOT NULL
- NULL
- UNIQUE
- CHECK：`CHECK(<行名> IN('<value1>', 'value2', 'value3'))`
- DEFAULT：`DEFAULT 'value'`
表约束：
- 复合主键
	`CONSTRAINT <复合键名> PRIMARY Key(<列名1>, <列名2>)`
- 代理键
	`CONSTRAINT <代理键名> PRIMARY Key(<列名>)`
	`<列名>` 需是：`serial`
- 外键
	`CONSTRAINT <外键名> FOREIGN Key(外键列名) REFERENCES <参照表>(参照列)`

## 3.1. DDL
```sql
--创建数据库
CREATE DATABASE 数据库名;

--创建表
CREATE TABLE 表名
(<列名1> <数据类型> [<列完整性约束>],
<列名2> <数据类型> [<列完整性约束>],
	……
CONSTRAINT ……
);

--增加列
ALTER TABLE <表名> ADD <列名> <数据类型> [完整性约束];

--添加约束
ALTER TABLE <表名> ADD CONSTRAINT …… ;

--增加索引
CREATE INDEX <索引名> ON <表名>(<列名>);
------------------------------
--删除表
DROP TABLE 表名;

--删除列
ALTER TABLE 表名 DROP COLUMN 列名;

--删除约束
ALTER TABLE <表名> DROP CONSTRAINT <约束名>;

--删除索引
DROP INDEX <索引名>;
------------------------------
--修改表名
ALTER TABLE <旧表名> RENAME TO <新表名>;

--修改列
ALTER TABLE <表名> ALTER COLUMN <列名> TYPE <数据类型>;
ALTER TABLE <表名> ALTER COLUMN <列名> SET NOT NULL;
ALTER TABLE <表名> ALTER COLUMN <列名> DROP NOT NULL;
ALTER TABLE <表名> RENAME COLUMN <旧列名> TO <新列名>;

--修改约束名
ALTER TABLE <表名> RENAME CONSTRAINT <旧约束名> TO <新约束名>;

--修改索引名
ALTER INDEX <旧索引名> RENAME TO <新索引名>;
```
新增列时**不能添加**`NULL`，数据库不知道如何为所有行添加该属性值，可设为 `DEFAULT` 或 `NOT NULL`

## 3.2. DML
```sql
--插入单行
INSERT INTO 表名 (列名1, 列名2, ...)
VALUES (值1, 值2, ...);

--插入多行
INSERT INTO 表名 (列名1, 列名2, ...)
VALUES (值1, 值2, ...),
	……
VALUES (值1, 值2, ...);

--更新
UPDATE 表名
SET 列名1 = 值1, 列名2 = 值2, ...
[WHERE 查询条件];

--删除
DELETE FROM 表名
[WHERE 查询条件];
```

## 3.3. DQL
```sql
--查询
SELECT [ALL | DISTINCT] <目标列1>[, <目标列2>, ……]
[INTO <新表>]
FROM <表名1>[, <表名2>, ……]
[WHERE <查询条件>]
[GROUP BY <列名> [HAVING <表达式>]]
[ORDER BY <列名> [ASC |DESC]];

--WHERE查询条件
WHERE <列名> BETWEEN <下界> AND <上界>;
WHERE 列名 >= 下界 AND 列名 <= 上界;
WHERE <列名> LIKE '_%'; --'_': 一个未指定，'%': 一个或多个未指定

--聚合函数：AVG()、COUNT()、MIN()、MAX()、SUM()
SELECT COUNT(*) FROM ……;
SELECT COUNT([DISTINCT] <列名>) FROM ……;

--分组统计
SELECT ……
FROM ……
WHERE ……
GROUP BY ……
HAVING COUNT(*) > 3;  --HAVING COUNT([DISTINCT] <列名>) > 3

--WHERE子句中使用AND、OR、NOT进行逻辑运算

--使用IN关键字限定范围
SELECT ……
FROM ……
WHERE <列名> IN (<值1>, <值2>, ……);

--子查询
SELECT ……
FROM ……
WHERE <列名> IN 
(SELECT <列名>
FROM ……
WHERE <查询条件>
);

--连接查询
SELECT <目标列1>[, <目标列2>, ……]
FROM <表名1>[, <表名2>, ……]
WHERE <表之间的连接条件>;

--JOIN...ON连接
SELECT <目标列1>[, <目标列2>, ……]
FROM <表名1> JOIN <表名2> ON <连接条件>;
```

## 3.4. DCL
```sql
--授予
GRANT 权限列表 ON 数据库对象 TO 用户/角色;

--收回
REVOKE 权限列表 ON 数据库对象 FROM 用户/角色;

--拒绝
DENY 权限列表 ON 数据库对象 TO 用户/角色;
```

## 3.5. 视图
```sql
--创建视图
CREATE [OR REPLACE] VIEW <视图名> [(<列名1>, <列名2>, ……)] AS <查询>;

--删除视图
DROP VIEW <视图名>;

--视图查询
SELECT * FROM <视图名>;
```

# 4. 数据库设计
数据库设计：应用架构设计、结构模型设计、访问方式设计
数据库结构模型：
- 概念数据模型（CDM）
- 逻辑数据模型（LDM）
- 物理数据模型（PDM）

| CDM             | LDM                             | PDM     |
| --------------- | ------------------------------- | ------- |
| 实体              | 实体                              | 表       |
| 属性              | 属性                              | 列       |
| 标识符（Identifier） | 标识符（Primary/Foreign Identifier） | 键       |
| 联系              | 联系                              | 参照完整性约束 |
ER 图元素：
1. 实体
2. 属性
3. 标识符
4. 联系
	联系度数：联系中关联实体数目
	基数：可能参与联系的实例的数量

实体 - 联系类型：
1. 多重性分类
	- 1 对 1
	- 1 对多
	- 多对多
2. 参与性分类
	- 可选
	- 强制
3. 继承性分类
	- 互斥继承：父实体中的一个实例只能属于某个子实体
	- 非互斥继承：父实体的一个实例可以属于多个子实体
	- 完整继承：父实体中的实例完整地被各个子实体分别继承
	- 非完整继承

强弱实体：一个实体（弱实体）的存在必须以另一个实体（强实体）的存在为前提
弱实体：
- 标识符依赖弱实体
- 非标识符弱实体

数据库建模设计：
1. CDM：
	- 定义实体、实体联系、实体属性、标识符
	- 不定义主、外键
2. LDM：
	- 主、外键定义（`Pi`、`Fi`）
	- 将多对多实体转化为一对多实体
	- 范式检查
3. PDM：
	1. 实体→关系表
		- 设置代理键
		- 设置列特性
	2. 弱实体→关系表
		- 非标识符依赖：弱实体关系表中加入强实体标识符做外键
		- 标识符依赖：弱实体关系表中加入强实体标识符做外键，并与若实体标识符一起做复合主键
	3. 实体联系转换
		- 1:1 转换：一个表主键放入另一个表做外键
		- 1:N 转换：1 端主键放入 N 端做外键
		- M:N 转换：增加关联表，M、N 端实体在关联表中做复合主键、外键
	4. 实体继承联系转换
		父表主键放在子表做主、外键
	5. 实体递归联系转换
		- 1:N 递归联系：关系表中添加一个参照约束于主键的外键
		- M:N 递归联系：增加关联表，原表的主键在关联表中派生两次做复合主键、外键

函数依赖：
- 完全函数依赖
- 部分函数依赖
- 传递函数依赖
- 多值依赖

关系规范化范式：
1. 第 1 范式：关系表中的属性不可再分
2. 第 2 范式：1NF 之上消除属性部分函数依赖
3. 第 3 范式：2NF 之上切断属性传递函数依赖
4. 巴斯 - 科德范式：任意一个非平凡函数依赖 X->A，都满足 X 是 R 的一个超键
5. 第 4 范式：BCNF 之上消除多值函数依赖

# 5. 数据库管理
为什么需要数据库管理：
- 随规模增大，系统复杂
- 多用户数据库应用→访问复杂性
- 数据安全、隐私
- 数据量增加、使用时间增长→性能降低
- 意外事件→数据库损坏、数据丢失

数据库管理目标：
- 稳定运行、存取性能
- 软硬件处理能力
- 系统安全、用户隐私
- 管理用户、角色权限
- 性能优化、系统故障、机器损坏
- 信息资产作用

DBMS 层次结构：
1. 访问接口层
2. 语言翻译处理层
3. 数据存取控制层
4. 数据存储管理层

数据库存储结构：
- 逻辑存储结构
- 物理存储结构
	至少有：数据文件、控制文件、重做日志文件

数据文件记录结构：
1. 定长记录
2. 变长记录

数据文件的记录组织：
1. 堆文件组织
2. 顺序文件组织
3. 多表聚簇文件组织
4. Hash 文件组织

数据字典：存放数据库元数据的系统数据库表及其视图
存储以下类型的元数据：
- 数据库表、视图的结构数据
- 系统角色、用户数据
- 索引数据

存储引擎：
- 外存管理器
- 内存数据缓存区
- 缓冲区管理器
- 索引管理器

B+ 树索引：
- 根、中间层节点：索引的搜索键值、下层节点指针
- 叶节点：索引的搜索键值、数据记录指针、链表指针

散列表索引：
- 散列函数
- 散列冲突解决

事务：由构成单个逻辑处理单元的一组数据库访问操作，要么都被成功执行，要么都不执行
![](image/Pasted%20image%2020250426113057.png)
ACID 特性：
- 原子性（Atomicity）：要么全正确执行，要么全不执行
- 一致性（Consistency）：从一种正确的数据状态变迁到另一种正确的数据状态
- 隔离性（Isolation）：事物之间隔离，并发执行透明
- 持续性（Durability）：一旦提交，对数据的改变是永久的

事务 SQL 编程：
- `BEGIN` 或 `START TRANSACTION`：开始
- `COMMIT`：提交
- `ROLLBACK`：回滚
- `SAVEPOINT`：保存点

事务处理**不能**有 DDL 类语句：该类语句会自动提交，导致事务终端
DBMS 默认每个语句构成一个事务

并发控制的目的：
- 支持并发事务，多用户并行操作
- 保证一个事务的工作不会对另一个事务的工作产生不合理影响

并发需要解决的问题：
1. 脏读：事务读取了取消被持久化更新的共享数据
2. 不可重复读：事务对同一共享数据重复读取，第二次读取的数据改变或丢失
3. 幻象读：事务对同一共享数据重复读取，第二次读取的结果比第一读取的结果新增数据
4. 丢失更新：事务对共享数据进行更新后查询值与其更新值不同

并发事务调度：控制多个事务数据操作语句按照恰当顺序访问共享数据，使这些事务执行后，避免数据的不一致性

DBMS 并发事务调度目标：使并发事务调度实现的处理结果与串行化调度处理结果一致

排他锁（Lock-X）：写锁，可以读、写，其它事务不能对共享数据加任何锁
共享锁（Lock-S）：读锁，只能读，其它事务只能再加 S 锁

锁的相容性：

|   类型    | 排他锁 | 共享锁 | 无锁  |
| :-----: | :-: | :-: | :-: |
| **排它锁** |  否  |  否  |  是  |
| **共享锁** |  否  |  是  |  是  |
| **无锁**  |  是  |  是  |  是  |

加锁协议：
1. 一级加锁协议：修改前加排它锁，事务完成后释放
	解决：丢失更新
2. 二级加锁协议：一级之上，读取前加共享锁，读后立即释放
	解决：脏读
3. 三级加锁协议：一级之上，读取前加共享锁，事务结束后释放
	解决：不可重复读


| 加锁协议级别 | 排他锁 | 共享锁  | 丢失更新 | 脏读  | 不可重复读 |
| :----: | :-: | :--: | :--: | :-: | :---: |
|   一级   | 全程  |  不加  |  否   |  是  |   是   |
|   二级   | 全程  | 读完释放 |  否   |  否  |   是   |
|   三级   | 全程  |  全程  |  否   |  否  |   否   |

并发事务的正确调度准则：一个并发事务调度，当且仅当可串行化时，才能保证正确调度
保证可串行化协议：二阶段锁定协议
二阶段锁定协议：
- 增长阶段：获得锁，不能释放锁
- 缩减阶段：释放锁，不能获得锁

事务死锁：并发事务执行时，同时锁定两个及以上资源时，彼此都不能继续执行的状态
死锁必要条件：
- 互斥条件
- 请求和保持条件
- 不可剥夺条件
- 环路等待条件

防范策略：
- 一次锁定全部所需资源
- 锁定资源顺序相同
解决死锁的办法：回滚一个事务

事务隔离级别：通过设置隔离级别来解决并发事务访问数据问题

| 隔离级别  | 脏读  | 不可重复读 | 幻像读 |
| :---: | :-: | :---: | :-: |
| 读取未提交 | 可能  |  可能   | 可能  |
| 读取已提交 | 不可能 |  可能   | 可能  |
| 可重复读  | 不可能 |  不可能  | 可能  |
| 可串行化  | 不可能 |  不可能  | 不可能 |
1. 读取未提交：允许读取未提交数据
2. 读取已提交：只允许读取已提交数据
3. 可重复读：2.之上两次读取时其他事务不允许**更新**（不是插入）
4. 可串行化

安全模型：
- 身份验证：应用系统层
- 权限控制：DBMS 系统层
- 系统防护：操作系统层
- 加密存储：数据存储层

安全管理：
- 用户管理：创建、修改、删除用户
- 权限管理
	- 权限类别：
		1. 对象访问权限
		2. 对象定义权限
	- 权限管理：
		```sql
		GRANT <权限列表> ON <数据库对象> TO <用户或角色>;
		REVOKE <权限列表> ON <数据库对象> FROM <用户或角色>;
		DENY <权限列表> ON <数据库对象> TO <用户或角色>;
		```
- 角色管理
	- 角色：一组相同权限的用户
	- 管理内容：创建、修改、删除角色

数据库备份：将数据、状态进行副本复制
数据库恢复：将数据丢失或被破坏时，从备份副本将数据库恢复到某一正确状态

备份内容：用户、系统数据库
备份方式：
- 完整数据库备份
- 差异数据库备份
- 事务日志备份
- 文件备份

根据是否需要停止实例运行：
- 冷备份
- 热备份

数据库恢复
1. 恢复场景
	- 事务故障的数据恢复
	- 系统崩溃的数据恢复
	- 存储介质损坏的数据恢复
2. 恢复技术
	利用数据库备份文件和数据库系统事务日志文件来实现数据库恢复处理

# 6. 数据库函数编程
## 6.1. 函数&变量
```sql
--声明变量
DECLARE
	<变量名> <变量类型>;

--行类型变量
<变量名> <表名>% ROWTYPE;

--用已有变量定义新变量
<变量1> <变量2>% TYPE;
<变量> <表名>.<列名>% TYPE;
```
- `RECORD` 类型变量是数据类型的占位符

```sql
--函数定义
CREATE [OR REPLACE] FUNCTION <函数名> [(<参数>)]
[RETURNS <返回类型> | VOID | TABLE(<列名> <列属性>, ……) | TRIGGER]
AS $$
DECLARE
	--声明变量
BEGIN
	--函数体语句
RETURN {<返回变量名> | <返回值>};
END;
$$LANGUAGE plpgsql;

--函数调用
--返回标量的函数
SELECT 函数名(参数1, 参数2, ...);
--返回表的函数
SELECT * FROM 函数名(参数1, 参数2, ...);
--作为表达式的一部分使用
SELECT product_name, calculate_discount(price) AS price FROM products;
SELECT * FROM orders WHERE is_order_valid(order_date);
UPDATE employees SET bonus = calculate_bonus(salary, performance_rating);

--函数删除
DROP FUNCTION [IF EXISTS] 函数名(参数列表) [CASCADE | RESTRICT];

--若 RETURN TABLE，需要 RETURN QUERY ……
CREATE OR REPLACE FUNCTION get_high_paid_employees(min_salary NUMERIC)  
    RETURNS TABLE (……)
AS  
$$  
begin  
    RETURN QUERY    
    SELECT ……
    FROM ……  
    WHERE ……;
end;  
$$ LANGUAGE plpgsql;
```


```sql
--IF
IF <布尔> THEN
END IF;

--IF-THEN-ELSIF-ELSE
IF <布尔> THEN
	……
ELSIF <布尔> THEN
	……
ELSE
	……
END IF;

--CASE
CASE
	WHEN <条件> THEN
		……;
	WHEN <条件> THEN
		……;
	……
	ELSE
		……;
END CASE;

--LOOP, 用EXIT, RETURN跳出循环
LOOP
	……
END LOOP;

--WHILE
WHILE <条件> LOOP
	……
END LOOP;

--FOR, 两个'.'
FOR i IN 1..<max> LOOP
	……
END LOOP;

--遍历结果
FOR <变量> IN <query> LOOP
	……
END LOOP;

--异常
BEGIN
	<语句>；
	EXCEPTION WHEN <异常> THEN
	<处理异常>;
END;

--NOTICE
RAISE NOTICE '格式化消息 % %', 变量1, 变量2;
```

## 6.2. 游标
- 临时的数据库对象
- 存放查询返回的数据记录
- 提供提取、处理每一条记录机制
- 总与一条 SQL 查询语句关联
- 包括：SQL 查询结果，指向特定记录的指针
打开、读取需在同一事务中，事务结束游标会隐含关闭
```sql
--非绑定游标
<游标名> REFCURSOR;

--绑定游标
<游标> CURSOR [(<参数1>, <参数2>, ……)] FOR <查询>;

--打开游标（非绑定）
OPEN <非绑定游标> FOR <查询>;
OPEN <非绑定游标> FOR EXECUTE '<查询字符串>';
--打开游标（绑定）
OPEN <已绑定游标> [(<参数>)];

--FETCH读取游标记录
FETCH [<方向> {FROM | IN}] <游标名> INTO <目标变量>;
---<方向>：
--NEXT: 移动到下一条（默认）
--PRIOR: 回退一条记录
--LAST: 移动到最后第一条
--FIRST: 移动到最后一条
--ABSOLUTE count: 移动到第count条记录
--RELATIVE count: 向前(count为正)/后(count为负)移动
--{FROM | IN}: 无作用，提高代码可读性

--FOUND判断是否获得数据
IF FOUND THEN
    -- 成功获取到数据时的处理
ELSE
    -- 没有获取到数据时的处理
END IF;

--MOVE移动游标
MOVE [<方向> {FROM | IN}] <游标名>;

--更新记录
UPDATE <表名> SET …… WHERE CURRENT OF <游标名>;
DELETE FROM <表名> WHERE CURRENT OF <游标名>;

--关闭游标
CLOSE <游标名>;
```

## 6.3. 存储过程
- 数据库对象
- 一组完成特定功能的 SQL 语句集
- 封装重复用的 SQL 语句
- 再次调用不用编译
- 给出存储过程名、参数调用
```sql
--存储过程定义
CREATE [OR REPLACE] PROCEDURE <存储过程名> [(<参数>)]
AS $$
DECLARE
	--声明变量
BEGIN
	--程序执行体语句
END;
$$LANGUAGE plpgsql;

--使用存储过程
CALL 存储过程名([<参数>]);

--在存储过程中调用其它存储过程
SELECT INTO <变量> FROM 存储过程名([<参数>]);

--修改存储过程
ALTER PROCEDURE 存储过程名([参数]) RENAME TO <新名>;

--删除存储过程
DROP PROCEDURE [IF EXISTS] <存储过程名>([<参数>]) [CASCADE | RESTRICT];
--IF EXISTS: 如果不存在则不会提示不存在
--CASCADE: 自动删除依赖该函数的对象
--RESTRICT（默认）: 如果有依赖对象则拒绝删除
```
- 无返回值，只能通过 `OUT` 类型参数传出值

存储过程优点：
- 减少网络通信量
- 执行速度快
- 更强的适应性
- 降低业务实现、应用程序耦合
- 降低开发复杂性
- 保护数据库元信息
- 增强安全性

存储过程缺点：
- SQL 为结构化语言，存储过程为过程化程序；对复杂业务逻辑，过程化处理逻辑复杂；SQL 优势是面向数据查询而非业务逻辑处理
- 开发调试复杂，缺乏支持存储过程 IDE
- 可移植性差

## 6.4. 触发器
- 特殊类型的存储过程
- 由 INSERT、UPDATE、DELETE 触发
- 实现比约束复杂的数据完整性
- 特殊的事务单位

特点：
- 必须定义在表或视图上
- 自动触发
- 不能调用、传参
- 事务的一部分

按执行次数分：
- 语句级（默认）：`FOR EACH STATEMENT`，执行一条 SQL 只执行一次
- 行级：`FOR EACH ROW`，每变化一行执行一次

按触发时间分：
- BEFORE：触发事件之前执行
- AFTER：触发事件之后执行
- INSTEAD OF：触发事件发生后，执行指定函数，不执行触发事件的 SQL 语句
	INSERT、UPDATE、DELETE 每个最多定义一个 INSTEAD OF 触发器

特殊变量：
- NEW
	RECORD 类型，对行级触发器，存放 INSERET 或 UPDATE 操作产生的新数据行；语句级触发器为 NULL
- OLD
	RECORD 类型，对行级触发器，存放 DELETE 或 UPDATE 操作删除、修改的新数据行；语句级触发器为 NULL
- TG_OP
	TEXT 类型，值为 INSERT、UPDATE、DELETE 中一个的字符串，指示引发操作

```sql
--创建触发器
CREATE TRIGGER <触发器名>
 {BEFORE | AFTER | INSTEAD OF}
 ON <表名>
 [FOR [EACH] {ROW | STATEMENT}]
 EXECUTE FUNCTION <函数名>([<参数列表>])
 
--触发器修改
ALTER TRIGGER <原触发器名> ON <表名> RENAME TO <新名字>;

--触发器删除
DROP TRIGGER [IF EXISTS] <触发器名> ON <表名> [CASCADE | RESTRICT];
```

触发器所使用的函数：
- 函数**声明**需 `RETURN TRIGGER`
- BEFORE INSERT/UPDATE：`RETURN NEW` ，可以修改、返回 `NEW`
- BEFORE DELETE：`RETURN OLD`，进行删除前的验证
- `RETURN NULL`：取消当前操作
- AFTER 触发器：返回值无作用（写上即可）
- INSTEAD OF 触发器：返回值无作用（通常：`RETURN NULL`）

常用函数
- `NOW()`：获取当前时间戳
- `CURRENT_USER`：返回当前用户