# 第6章 代码优化与目标代码生成

## 代码优化

中间代码优化：

- 局部优化（基本块优化）
  - 常数合并与传播
  - 删除公共子表达式
  - 复制传播
  - 削弱计算强度
  - 改变计算次序
- 循环优化
  - 循环展开
  - 代码外提
  - 削弱计算强度
  - 删除归纳变量
- 全局优化
  - 在非线性程序段上进行的优化



### 划分基本块

1. 入口语句：
   - 第一条语句
   - 能转移到的语句
   - 紧随**条件转移**语句后面的语句
2. - （入口语句，下一条入口语句)
   - （入口语句，转移语句 ]
   - （入口语句，停顿语句 ]
3. 删除未出现在任何基本块中的语句



### 基本块优化

**删除公共子表达式：**第一次对E求值后，如果E的运算对象都没有变，再次对E求值（除第一次求值，其余都是冗余的公共表达式）

**复写传播：**进行`a = b`赋值后，若a、b都没变化，则对a的引用可用b来代替

**删除无用代码：**删除不可到达代码、删除死变量、删除死代码（可执行，但执行结果无作用）、删除死块

**代数恒等变换：**

- 合并已知量：编译时可计算出的表达式直接用值代替
- 常数传播：用编译时已知的变量值来代替对这些变量的引用
- 削弱计算强度：用代数上等价的形式代替求值计算
- 改变计算次序：两个语句不相互依赖，可改变计算次序（寄存器分配时可能减少读取内存单元的次数）
- 代数化简：`i = -(-i)`
- 变量重新组合：利用交换律、结合律、分配律改写，充分利用已定值的变量



### DAG在局部优化中的应用

- 每个结点外标号，节点内标运算符
- 子节点为右值
- 父节点为左值

常用三地址语句的DAG：

| 表达式             | 节点                                                         |
| ------------------ | ------------------------------------------------------------ |
| x = y (y不存在)    | <img src="image/image-20241208201412890.png" alt="image-20241208201412890" style="zoom:67%;" /> |
| x = y (y已存在)    | <img src="image/image-20241208201423921.png" alt="image-20241208201423921" style="zoom:67%;" /> |
| x = op y           | <img src="image/image-20241208201454027.png" alt="image-20241208201454027" style="zoom:67%;" /> |
| x= y op z          | <img src="image/image-20241208201613432.png" alt="image-20241208201613432" style="zoom:67%;" /> |
| x = y[z]           | <img src="image/image-20241208201634155.png" alt="image-20241208201634155" style="zoom:67%;" /> |
| x[y] = z           | <img src="image/image-20241208201846017.png" alt="image-20241208201846017" style="zoom:67%;" /> |
| if x op y goto (s) | <img src="image/image-20241208202041018.png" alt="image-20241208202041018" style="zoom:67%;" /> |
| goto(s)            | <img src="image/image-20241208202054844.png" alt="image-20241208202054844" style="zoom:67%;" /> |

依据DAG对每个基本块进行优化



### 循环优化

循环查找：看局部强连通外是否有大于一个箭头指向其节点（多个入口）

#### 代码外提

条件：

- 循环所有出口的必经结点
- 不变运算：结果不变
- 对`X = Y op Z`循环中其他地方不能对X再定值，且对X的所有引用值均为该运算确定的X的值
- 代码外提：将不变运算的代码放到循环外执行

#### 强度削弱

将中高强度的运算用强度低的运算替代

```python
T = K * I ± D 
T’= K * (I ± C) ± D
T ’= K*I ± K*C ± D

#得到
T ’= T + K*C
```

#### 删除归纳变量

基本归纳变量：变量I仅有I = I ± C形式的赋值，I为基本归纳变量

若I为基本归纳变量，J可化为与I统一线性函数的形式：J = C1 * I ± C2，则称J与I同族

在同族归纳变量中用其中一个来代替基本归纳变量进行循环控制，去掉其余的归纳变量

## 目标代码生成

### 寄存器分配

将程序中数量几乎无限的虚拟寄存器映射到数量有限的物理寄存器中，尽量将活跃的变量放在寄存器中

#### 图着色算法

图着色：将生存期看成顶点，冲突定义为边

K-着色：最多由K个寄存器

1. 找到邻居节点数小于K的节点，临时删除它
2. 重复1，直到空图或无法删除
3. - 若空图，则通过与2相反步骤着色
   - 若无法删除，可引入保存，将某个节点溢出

#### 线性扫描

生存周期：变量从被赋值到最后一次被引用

1. 计算生存期
2. 根据开始时间排序写入表Live_intervals
3. 根据结束时间排序写入表Active

将生存周期长的变量可考虑**一直**溢出到`Spill = { }`中

将每一时间段小于寄存器数的活跃变量放在`active = { }`中