# 第3章 词法分析

## 由正规式构造DFA

1. 由画NFA图

2. 根据Next(A, c)函数来构造闭包

   由A经c可以跳转到的所有状态，初始不包含A的状态

3. 画状态转移矩阵

   | 状态 | a    | b    |
   | ---- | ---- | ---- |
   | A    | B    | C    |
   | B    | A    | -    |
   | C    | -    | C    |

4. 根据包含初状态、末状态划分状态集

   将经同一符号转化所得到的状态不同的状态集划分（**不能转换**也是一种特殊的状态形式）

5. 画出DFA



# 第4章 语法分析-自上而下

## LL(1)预测分析表

1. 提取公共左因子、消除左递归（直接、间接）

2. 计算**右式**的FIRST()集

3. 对**右式FIRST()集包含空**的**左式**计算FOLLOW()集

   - 文法起始符号的FOLLOW()有**#**

4. 画预测分析表

   |      | !     | *    | #    |
   | ---- | ----- | ---- | ---- |
   | E    | E→TA  |      | A→ε  |
   | A    | A→+TA | A→ε  |      |

   最后一行有**#**！！！



## 使用分析表进行分析

| 步骤 | 下推栈 | 输入串          | 产生式 |
| ---- | ------ | --------------- | ------ |
| 0    | **#S** | i + i * i **#** | S→TS   |

1. 开始时下推栈为**#S**，输入串末尾为**#**
2. 若栈顶与当前字符相同则同时弹出
3. 若为产生式，则将栈中左部替换为逆序的右部（逆序压栈）
4. 直到均为**#**号分析成功



# 第4章 语法分析-自下而上

## LR(0)、SLR(1)分析表

1. 若初始状态不唯一（S有多个候选），则先对文法进行拓广

2. 对有多个右部的产生式进行拆分

3. 画活前缀的有限自动机（构造项目集规范簇）

   对A→ε添加为A→·

   对一条路画到底再画另一条路

4. 构造**LR(0)**分析表

   | 状态 | ACTION |      |       | GOTO |      |      |
   | ---- | ------ | ---- | ----- | ---- | ---- | ---- |
   |      | a      | (    | **#** | A    | E    | L    |
   | 0    | r1     | r1   | r1    | 1    |      |      |
   | 1    | s3     | s1   | acc   |      | 0    | 1    |

   归约时无条件

   包含**·**在末尾的项目（非S）进行归约，对终结符跳转填移进，对非终结符跳转填GOTO

   若状态包含类似S→E·的项目集，则在该状态行，**#**列添加acc

5. 构造**SLR(1)**分析表

   对于P→α·，只对FOLLOW(P)进行归约



## 使用分析表进行分析

| 步骤 | 状态栈 | 符号栈 | 输入串          | 动作 |
| ---- | ------ | ------ | --------------- | ---- |
| 1    | **0**  | **#**  | i + i * i **#** | S5   |
| 2    | 05     | # i    | + i * i **#**   | R6   |

1. 初始时状态栈为初始状态，符号栈为#，剩余串末尾加#

2. 工作：下一个步骤需要进行的操作

3. 移进：将状态、符号同时压栈

4. 归约：用产生式对状态栈、符号栈弹出**右部个数**个状态、符号，符号栈压入左部，补缺失的状态

   弹出→压左部→补状态



# 第6章 代码优化与目标代码生成

## 代码优化

中间代码优化：

- 局部优化（基本块优化）
  - 常数合并与传播
  - 删除公共子表达式
  - 复制传播
  - 削弱计算强度
  - 改变计算次序
- 循环优化
  - 循环展开
  - 代码外提
  - 削弱计算强度
  - 删除归纳变量
- 全局优化
  - 在非线性程序段上进行的优化



### 划分基本块

1. 入口语句：
   - 第一条语句
   - 能转移到的语句
   - 紧随**条件转移**语句后面的语句
2. - （入口语句，下一条入口语句)
   - （入口语句，转移语句 ]
   - （入口语句，停顿语句 ]
3. 删除未出现在任何基本块中的语句



### 基本块优化

**删除公共子表达式：**第一次对E求值后，如果E的运算对象都没有变，再次对E求值（除第一次求值，其余都是冗余的公共表达式）

**复写传播：**进行`a = b`赋值后，若a、b都没变化，则对a的引用可用b来代替

**删除无用代码：**删除不可到达代码、删除死变量、删除死代码（可执行，但执行结果无作用）、删除死块

**代数恒等变换：**

- 合并已知量：编译时可计算出的表达式直接用值代替
- 常数传播：用编译时已知的变量值来代替对这些变量的引用
- 削弱计算强度：用代数上等价的形式代替求值计算
- 改变计算次序：两个语句不相互依赖，可改变计算次序（寄存器分配时可能减少读取内存单元的次数）
- 代数化简：`i = -(-i)`
- 变量重新组合：利用交换律、结合律、分配律改写，充分利用已定值的变量



### DAG在局部优化中的应用

- 每个结点外标号，节点内标运算符
- 子节点为右值
- 父节点为左值

常用三地址语句的DAG：

| 表达式             | 节点                                                         |
| ------------------ | ------------------------------------------------------------ |
| x = y (y不存在)    | <img src="image/image-20241208201412890.png" alt="image-20241208201412890" style="zoom:67%;" /> |
| x = y (y已存在)    | <img src="image/image-20241208201423921.png" alt="image-20241208201423921" style="zoom:67%;" /> |
| x = op y           | <img src="image/image-20241208201454027.png" alt="image-20241208201454027" style="zoom:67%;" /> |
| x= y op z          | <img src="image/image-20241208201613432.png" alt="image-20241208201613432" style="zoom:67%;" /> |
| x = y[z]           | <img src="image/image-20241208201634155.png" alt="image-20241208201634155" style="zoom:67%;" /> |
| x[y] = z           | <img src="image/image-20241208201846017.png" alt="image-20241208201846017" style="zoom:67%;" /> |
| if x op y goto (s) | <img src="image/image-20241208202041018.png" alt="image-20241208202041018" style="zoom:67%;" /> |
| goto(s)            | <img src="image/image-20241208202054844.png" alt="image-20241208202054844" style="zoom:67%;" /> |

依据DAG对每个基本块进行优化



### 循环优化

循环查找：看局部强连通外是否有大于一个箭头指向其节点（多个入口）

#### 代码外提

条件：

- 循环所有出口的必经结点
- 不变运算：结果不变
- 对`X = Y op Z`循环中其他地方不能对X再定值，且对X的所有引用值均为该运算确定的X的值
- 代码外提：将不变运算的代码放到循环外执行

#### 强度削弱

将中高强度的运算用强度低的运算替代

```python
T = K * I ± D 
T’= K * (I ± C) ± D
T ’= K*I ± K*C ± D

#得到
T ’= T + K*C
```

#### 删除归纳变量

基本归纳变量：变量I仅有I = I ± C形式的赋值，I为基本归纳变量

若I为基本归纳变量，J可化为与I统一线性函数的形式：J = C1 * I ± C2，则称J与I同族

在同族归纳变量中用其中一个来代替基本归纳变量进行循环控制，去掉其余的归纳变量

## 目标代码生成

### 寄存器分配

将程序中数量几乎无限的虚拟寄存器映射到数量有限的物理寄存器中，尽量将活跃的变量放在寄存器中

#### 图着色算法

图着色：将生存期看成顶点，冲突定义为边

K-着色：最多由K个寄存器

1. 找到邻居节点数小于K的节点，临时删除它
2. 重复1，直到空图或无法删除
3. - 若空图，则通过与2相反步骤着色
   - 若无法删除，可引入保存，将某个节点溢出

#### 线性扫描

生存周期：变量从被赋值到最后一次被引用

1. 计算生存期
2. 根据开始时间排序写入表Live_intervals
3. 根据结束时间排序写入表Active

将生存周期长的变量可考虑**一直**溢出到`Spill = { }`中

将每一时间段小于寄存器数的活跃变量放在`active = { }`中





- 正则**文法**≠正则式
- 短语、直接短语、句柄P17